---
title: 01-JavaScript 词法作用域（Lexical Scope）详解
---

作用域是用于查找标识符（变量和函数）的基本理论；理解作用域对于掌握 JavaScript 至关重要。

<!--more-->

## 1. 定义与核心概念

**动态作用域（Dynamic Scope）** JavaScript **并不支持**真正的动态作用域（动态作用域意味着函数的作用域在函数调用时才确定）。但 `this` 的机制在某些情况下与动态作用域的行为有些相似，不过它是由函数调用方式决定的。

**词法作用域**（Lexical Scope），也称为**静态作用域**（Static Scope），是 JavaScript 中用于确定变量和函数可访问范围的一套规则。这套规则的核心在于：**作用域在代码编写阶段（即词法分析阶段）就已经根据源代码的物理结构确定，而不是在代码运行时根据调用上下文动态确定**。

简单来说，一个标识符（变量或函数）的作用域取决于**它在代码中被书写的位置**，与它在哪里被调用无关。

## 2. 工作原理与作用域链

### 2.1 作用域的嵌套

JavaScript 中的作用域存在嵌套关系，通常分为：

- **全局作用域**：最外层环境。
- **函数作用域**：每个函数都会创建自己的作用域。
- **块级作用域**：由 `{}` 配合 `let` 和 `const` 关键字创建（ES6 引入）。
- **模块作用域**：ES6 引入的模块系统，每个模块都是一个独立的作用域。

内部作用域可以访问外部作用域的变量和函数，但外部作用域无法直接访问内部作用域的变量（除非通过闭包等机制）。

下面是 ES6 中主要作用域类型的对比表，帮你快速把握核心区别：

| 作用域类型     | 定义与范围                                                  | 声明关键字                        | 主要特点与行为                                                                                                                                     |
| :------------- | :---------------------------------------------------------- | :-------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------- |
| **全局作用域** | 代码最外层，任何地方都能访问                                | `var`, `let`, `const`, `function` | 在浏览器中属性和方法属于 `window` 对象；在 Node.js 中属于 `global` 对象；过度使用可能导致命名冲突和全局污染。                                      |
| **函数作用域** | 在函数内部声明的变量，仅限函数内部访问                      | `var`, `function`                 | `var` 声明的变量存在变量提升（Hoisting），即声明会被提升到函数顶部，初始化仍在原地；`function` 声明的函数整体提升。                                |
| **块级作用域** | 由一对花括号 `{}` 界定的代码区域（如 `if`, `for`, `while`） | `let`, `const`                    | **ES6 新增**。`let`/`const` 声明的变量仅在此块内有效；存在暂时性死区（TDZ），声明前访问会报错；不允许重复声明；解决了循环中的变量泄露问题。        |
| **模块作用域** | 在 ES6 模块（`<script type="module">`）内部                 | `let`, `const`                    | **ES6 新增**。模块内顶层的变量默认不被添加到全局作用域；需要通过 `export` 显式导出，再通过 `import` 导入使用；避免了全局污染，支持更好的代码组织。 |

### 🔍 关键细节与对比

#### 1. 块级作用域 (Block Scope) - ES6 核心新增

块级作用域由 `let` 和 `const` 关键字声明，有效解决了 ES5 中只有全局和函数作用域带来的一些问题。

- **解决变量提升问题**：`let` 和 `const` 声明的变量不存在变量提升，且在声明前存在**暂时性死区（Temporal Dead Zone, TDZ）**，访问会报错 `ReferenceError`。

  ```javascript
  console.log(a); // 输出 undefined (变量提升)
  var a = 10;

  console.log(b); // 报错 ReferenceError: Cannot access 'b' before initialization
  let b = 20;
  ```

- **避免循环变量泄露**：使用 `let` 声明循环变量，每次迭代都会创建一个新的绑定，非常适合在循环（尤其是异步循环）中使用。

  ```javascript
  // ES5 var 声明，i 会泄露到全局，且循环内异步操作都引用同一个 i
  for (var i = 0; i < 5; i++) {
    setTimeout(function () {
      console.log(i); // 输出 5, 5, 5, 5, 5
    }, 100);
  }

  // ES6 let 声明，每个 i 都是块级作用域内新的变量
  for (let i = 0; i < 5; i++) {
    setTimeout(function () {
      console.log(i); // 输出 0, 1, 2, 3, 4
    }, 100);
  }
  ```

- **禁止重复声明**：在相同作用域内，无法重复使用 `let` 或 `const` 声明同名变量。
  ```javascript
  let x = 1;
  let x = 2; // SyntaxError: Identifier 'x' has already been declared
  ```

#### 2. 函数作用域 (Function Scope) - ES5 主体

由 `var` 和 `function` 声明主导。

- **变量提升**：`var` 声明的变量会被提升到函数顶部（声明提升，初始化不提升）；`function` 声明的函数整体提升。

  ```javascript
  console.log(foo); // undefined
  var foo = "bar";

  sayHello(); // "Hello!"
  function sayHello() {
    console.log("Hello!");
  }
  ```

- **无块级作用域**：`var` 声明的变量不受 `{}` 块的影响，容易导致意外覆盖。
  ```javascript
  if (true) {
    var innerVar = "I'm inside";
  }
  console.log(innerVar); // "I'm inside" (变量泄露到外部作用域)
  ```

#### 3. 模块作用域 (Module Scope) - ES6 现代化封装

通过 `export` 和 `import` 关键字实现。

- **默认私有**：模块内顶层声明的变量、函数、类等，除非显式 `export`，否则在其他模块无法访问。

  ```javascript
  // module.js
  let privateVariable = "I am private";
  export let publicVariable = "I am public";

  // main.js
  import { publicVariable } from "./module.js";
  console.log(publicVariable); // "I am public"
  // console.log(privateVariable); // Error: privateVariable is not defined
  ```

- **避免全局污染**：是组织大型应用、避免命名冲突的终极方案。

#### 4. 全局作用域 (Global Scope) - 慎用

在所有函数和块之外声明的变量和函数。

- **潜在风险**：过度使用全局变量是命名冲突和代码难以维护的常见原因。在模块作用域中，顶层的 `var` 和 `function` 虽然不会成为全局对象的属性，但依然是全局可访问的（取决于环境）。

### 2.2 作用域链与变量查找

当在某个作用域中访问一个变量时，JavaScript 引擎会通过**作用域链**（Scope Chain）进行查找。
查找规则如下：

1.  首先在**当前作用域**内查找该变量。
2.  如果找不到，则向**上一层父级作用域**查找。
3.  依此类推，逐级向上，直到抵达**全局作用域**。
4.  如果在全局作用域中仍未找到，则会抛出 `ReferenceError`。

这个查找过程形成的链条就是作用域链，它基于代码的**词法结构**（嵌套关系）静态生成。

**示例**：

```javascript
let globalVar = "global"; // 全局作用域

function outer() {
  let outerVar = "outer"; // outer 函数作用域

  function inner() {
    let innerVar = "inner"; // inner 函数作用域
    console.log(innerVar); // 在当前作用域找到，输出 'inner'
    console.log(outerVar); // 向上层作用域找到，输出 'outer'
    console.log(globalVar); // 继续向上找到全局作用域，输出 'global'
  }

  inner();
}

outer();
```

即使 `inner` 函数在 `outer` 函数外部被调用，它依然只能访问其**定义时**的词法作用域链中的变量。

## 3. 词法作用域 vs. 动态作用域

| 特性         | 词法作用域（JavaScript）         | 动态作用域                   |
| :----------- | :------------------------------- | :--------------------------- |
| **确定时机** | 函数**定义时**确定               | 函数**调用时**确定           |
| **查找依据** | 代码的**书写位置**和**嵌套关系** | 函数的**调用栈**和顺序       |
| **可预测性** | 高，代码写好后作用域就固定       | 低，需要运行时上下文才能确定 |

JavaScript 采用的是**词法作用域**。以下示例清晰地说明了两者的区别：

```javascript
let x = 10;

function foo() {
  console.log(x);
}

function bar() {
  let x = 20;
  foo(); // 在 bar 函数内部调用 foo
}

bar(); // 输出 10（词法作用域），而非 20（动态作用域）
```

`foo` 的作用域在定义时就已确定，它访问的是全局变量 `x`（值为 10），而不是调用它的 `bar` 函数内部定义的 `x`。

## 4. 常见应用与模式

### 4.1 闭包（Closure）

**闭包是词法作用域的直接体现和最重要应用**。当一个函数可以**记住并访问其所在的词法作用域**，即使该函数在其词法作用域之外执行，就产生了闭包。

```javascript
function createCounter() {
  let count = 0; // createCounter 函数的局部变量
  return function () {
    return ++count; // 内部函数“记住”并访问了外部函数的 count 变量
  };
}

const myCounter = createCounter();
console.log(myCounter()); // 1
console.log(myCounter()); // 2
// myCounter 函数依然保持着对 createCounter 函数作用域的引用
```

### 4.2 模块模式（Module Pattern）

在 ES6 模块出现之前，常利用**立即调用函数表达式（IIFE）** 和词法作用域来创建私有变量，实现模块化，避免全局变量污染。

```javascript
const MyModule = (function () {
  let privateData = "I am private"; // 私有变量

  function privateMethod() {
    console.log(privateData);
  }

  return {
    // 返回公共接口
    publicMethod: function () {
      privateMethod();
    },
  };
})();

MyModule.publicMethod(); // 输出 "I am private"
// console.log(MyModule.privateData); // undefined，无法直接访问
```

### 4.3 函数工厂与柯里化

词法作用域允许函数**动态生成具有特定行为的函数**。

```javascript
// 函数工厂
function createMultiplier(multiplier) {
  return function (x) {
    return x * multiplier;
  };
}
const double = createMultiplier(2);
const triple = createMultiplier(3);
console.log(double(5)); // 10
console.log(triple(5)); // 15
```

## 5. 注意事项与常见陷阱

### 5.1 变量遮蔽（Variable Shadowing）

内层作用域的变量会遮蔽外层作用域的同名变量。

```javascript
let x = 10;
function foo() {
  let x = 20; // 遮蔽了外层的 x
  console.log(x); // 20
}
foo();
console.log(x); // 10 (全局的 x 未被改变)
```

### 5.2 循环中的闭包陷阱 (使用 `var` 时)

这是一个经典问题，由于 `var` 没有块级作用域，循环中创建的异步操作（如 `setTimeout`）会共享同一个变量引用。

```javascript
// 陷阱：输出 5, 5, 5, 5, 5
for (var i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i);
  }, 100);
}
```

**解决方案**：使用 `let`（块级作用域）或 IIFE 为每次迭代创建新的作用域。

```javascript
// 使用 let：输出 0, 1, 2, 3, 4
for (let i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i);
  }, 100);
}

// 使用 IIFE：输出 0, 1, 2, 3, 4
for (var i = 0; i < 5; i++) {
  (function (j) {
    setTimeout(function () {
      console.log(j);
    }, 100);
  })(i);
}
```

### 5.3 意外的全局变量

在非严格模式下，未使用 `var`、`let` 或 `const` 声明的变量会自动变为全局变量，这可能造成难以察觉的错误。

```javascript
function foo() {
  accidentalGlobal = "oops"; // 未声明，成了全局变量！
}
foo();
console.log(accidentalGlobal); // "oops"
```

**始终使用 `let` 或 `const` 声明变量，并启用严格模式（`"use strict"`）可避免此问题。**

## 6. 总结

| 特性         | 说明                                                       |
| :----------- | :--------------------------------------------------------- |
| **确定方式** | 由代码的**书写位置**决定，编译时静态生成。                 |
| **核心机制** | **作用域链**，变量查找沿链从内到外进行。                   |
| **关键特性** | **内部函数可访问外部作用域变量**（闭包的基础）。           |
| **主要优点** | **可预测性强**，代码行为在编写时即可确定，利于维护和调试。 |
| **主要应用** | 闭包、模块化、函数工厂、柯里化等。                         |
| **重要规则** | 使用 `let`/`const` 注意块级作用域和暂时性死区（TDZ）。     |

理解词法作用域是掌握 JavaScript 作用域、闭包、异步编程等核心概念的基础。它使得代码的行为更具可预测性，是编写可靠、可维护 JavaScript 程序的关键。
